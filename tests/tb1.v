//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Thu Jan 15 21:42:23 EST 2015
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module tb1(CLK,
	   RST_N);
  input  CLK;
  input  RST_N;

  // inlined wires
  wire fsm_start_wire$whas, fsm_state_set_pw$whas;

  // register a
  reg a;
  wire a$D_IN, a$EN;

  // register fsm_start_reg
  reg fsm_start_reg;
  wire fsm_start_reg$D_IN, fsm_start_reg$EN;

  // register fsm_start_reg_1
  reg fsm_start_reg_1;
  wire fsm_start_reg_1$D_IN, fsm_start_reg_1$EN;

  // register fsm_state_can_overlap
  reg fsm_state_can_overlap;
  wire fsm_state_can_overlap$D_IN, fsm_state_can_overlap$EN;

  // register fsm_state_fired
  reg fsm_state_fired;
  wire fsm_state_fired$D_IN, fsm_state_fired$EN;

  // register fsm_state_mkFSMstate
  reg [2 : 0] fsm_state_mkFSMstate;
  wire [2 : 0] fsm_state_mkFSMstate$D_IN;
  wire fsm_state_mkFSMstate$EN;

  // register simCycle
  reg [15 : 0] simCycle;
  wire [15 : 0] simCycle$D_IN;
  wire simCycle$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_always_run, WILL_FIRE_RL_fsm_fsm_start;

  // remaining internal signals
  reg [63 : 0] v__h10077, v__h10138;
  wire fsm_abort_whas_AND_fsm_abort_wget_OR_fsm_state_ETC___d44,
       fsm_start_wire_whas_AND_fsm_start_wire_wget_0__ETC___d38;

  // rule RL_always_run
  assign WILL_FIRE_RL_always_run =
	     fsm_abort_whas_AND_fsm_abort_wget_OR_fsm_state_ETC___d44 &&
	     !fsm_start_reg ;

  // rule RL_fsm_fsm_start
  assign WILL_FIRE_RL_fsm_fsm_start =
	     fsm_abort_whas_AND_fsm_abort_wget_OR_fsm_state_ETC___d44 &&
	     fsm_start_reg ;

  // inlined wires
  assign fsm_start_wire$whas =
	     WILL_FIRE_RL_fsm_fsm_start ||
	     fsm_start_reg_1 && !fsm_state_fired ;
  assign fsm_state_set_pw$whas =
	     fsm_state_mkFSMstate == 3'd1 ||
	     fsm_start_wire_whas_AND_fsm_start_wire_wget_0__ETC___d38 ;

  // register a
  assign a$D_IN = fsm_state_mkFSMstate != 3'd1 ;
  assign a$EN = fsm_state_set_pw$whas ;

  // register fsm_start_reg
  assign fsm_start_reg$D_IN = !WILL_FIRE_RL_fsm_fsm_start ;
  assign fsm_start_reg$EN =
	     WILL_FIRE_RL_fsm_fsm_start || WILL_FIRE_RL_always_run ;

  // register fsm_start_reg_1
  assign fsm_start_reg_1$D_IN = fsm_start_wire$whas ;
  assign fsm_start_reg_1$EN = 1'd1 ;

  // register fsm_state_can_overlap
  assign fsm_state_can_overlap$D_IN =
	     fsm_state_set_pw$whas || fsm_state_can_overlap ;
  assign fsm_state_can_overlap$EN = 1'd1 ;

  // register fsm_state_fired
  assign fsm_state_fired$D_IN = fsm_state_set_pw$whas ;
  assign fsm_state_fired$EN = 1'd1 ;

  // register fsm_state_mkFSMstate
  assign fsm_state_mkFSMstate$D_IN =
	     fsm_start_wire_whas_AND_fsm_start_wire_wget_0__ETC___d38 ?
	       3'd1 :
	       3'd2 ;
  assign fsm_state_mkFSMstate$EN =
	     fsm_start_wire_whas_AND_fsm_start_wire_wget_0__ETC___d38 ||
	     fsm_state_mkFSMstate == 3'd1 ;

  // register simCycle
  assign simCycle$D_IN = simCycle + 16'd1 ;
  assign simCycle$EN = 1'd1 ;

  // remaining internal signals
  assign fsm_abort_whas_AND_fsm_abort_wget_OR_fsm_state_ETC___d44 =
	     fsm_state_mkFSMstate == 3'd0 &&
	     (!fsm_start_reg_1 || fsm_state_fired) ;
  assign fsm_start_wire_whas_AND_fsm_start_wire_wget_0__ETC___d38 =
	     fsm_start_wire$whas && fsm_state_mkFSMstate == 3'd0 ||
	     fsm_state_mkFSMstate == 3'd2 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        a <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fsm_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fsm_state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	fsm_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 3'd0;
	simCycle <= `BSV_ASSIGNMENT_DELAY 16'd0;
      end
    else
      begin
        if (a$EN) a <= `BSV_ASSIGNMENT_DELAY a$D_IN;
	if (fsm_start_reg$EN)
	  fsm_start_reg <= `BSV_ASSIGNMENT_DELAY fsm_start_reg$D_IN;
	if (fsm_start_reg_1$EN)
	  fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY fsm_start_reg_1$D_IN;
	if (fsm_state_can_overlap$EN)
	  fsm_state_can_overlap <= `BSV_ASSIGNMENT_DELAY
	      fsm_state_can_overlap$D_IN;
	if (fsm_state_fired$EN)
	  fsm_state_fired <= `BSV_ASSIGNMENT_DELAY fsm_state_fired$D_IN;
	if (fsm_state_mkFSMstate$EN)
	  fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      fsm_state_mkFSMstate$D_IN;
	if (simCycle$EN) simCycle <= `BSV_ASSIGNMENT_DELAY simCycle$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    a = 1'h0;
    fsm_start_reg = 1'h0;
    fsm_start_reg_1 = 1'h0;
    fsm_state_can_overlap = 1'h0;
    fsm_state_fired = 1'h0;
    fsm_state_mkFSMstate = 3'h2;
    simCycle = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_always_run)
	begin
	  v__h10077 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_always_run)
	$display("I am noww running one more step at ", v__h10077);
    if (RST_N != `BSV_RESET_VALUE)
      if (simCycle == 16'd200)
	begin
	  v__h10138 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (simCycle == 16'd200)
	$display("[%d]: %m: tb termination", v__h10138);
    if (RST_N != `BSV_RESET_VALUE) if (simCycle == 16'd200) $finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE)
      if (fsm_start_wire_whas_AND_fsm_start_wire_wget_0__ETC___d38 &&
	  fsm_state_mkFSMstate == 3'd1)
	$display("Error: \"tests/TB1.bsv\", line 33, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_fsm_action_l33c9] and\n  [RL_fsm_action_l36c9] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // tb1

